# Notes on Conda Build and Relocatable Binaries

Conda builds (Using shared librarie...) relocatable binaries by including everything that is needed for a particular software into that conda environment, and linking to the appropriate libraries using a relative path. Generally, when compiling software from source, the LD_LIBRARY_PATH environmental variable is set to tell the software where to look for its library. If the LD_LIBRARY_PATH becomes set incorrectly, unset, or superseded by another software stack, the software would fail. Conda build instead uses RPATH, which hardcodes the linked libraries to a path relative to the binary within the conda environment. During the install process it changes from a linked path to an absolute path by substituting the original conda build prefix with the actual prefix.This is especially useful in bioinformatics, where a single analysis can have an very complex software dependency tree. A researcher may install a software that depends upon samtools < 1.0, such as soapdenovo2. They may also want to use a newer version of samtools for some upstream manipulation of bam files. This situation would be impossible if the user where trying to install them as root, as having two versions of samtools would not be possible. It would also be impossible if the user were trying to use these in an HPC module system where LD_LIBRARY_PATH is the norm, and layering modules without an underlying knowledge of the linked libraries.

# Conda on HPC

The conda ecosystem lends itself very well to traditional HPC module configurations, while allowing users without administrative privileges full control over their software stacks. An administrator can deploy one or more conda environments as an HPC module. These can be grouped together to give a variety of different combinations of interfaces for different analysis disciplines, projects, and labs by mixing and matching available software stacks. Under the hood administrators and users will use the same process, which is a greater gain to reproducible research. It makes the process of onboarding new users to HPC much easier, as any user has access to the same level of sophistication in software builds as an experienced applications specialist.  
